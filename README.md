Ниже вариант, который:

* **во-первых** фильтрует нужные депозиты («deals»);
* **во-вторых** берёт **у каждой** сделки дату `DT_CLOSE – 5 дней`;
* **в-третьих** вытягивает из огромной витрины балансов **только** те строки,
  где `CON_ID` ∈ deals **и** `DT_REP = DT_CLOSE-5`, причём `rate_trf` не NULL.

Так мы **один раз** читаем VW\_Balance\_Rest\_All по чёткому списку дат, а не
делаем тысячи «TOP 1 … ORDER BY» для каждой строки.

```sql
/*====================================================================
   1. Отбираем сделки (без-опционных, открыты 01-01-2025 … 24-06-2025)
      и у которых DT_CLOSE ≤ 24-06-2025
====================================================================*/
WITH deals AS (
    SELECT
        s.CON_ID,
        s.MATUR,
        s.DT_OPEN,
        s.DT_CLOSE,
        s.CONVENTION,
        Nadbawka = s.MonthlyCONV_ALM_TransfertRate - s.without_nadbawka,
        /* дата, по которой ищем баланс: DT_CLOSE – 5 дней */
        Target_DT = DATEADD(day, -5, s.DT_CLOSE)
    FROM ALM_TEST.WORK.DepositInterestsRateSnap_upd      s  WITH (NOLOCK)
    WHERE s.DT_OPEN  BETWEEN '2025-01-01' AND '2025-06-24'
      AND s.IS_OPTION = 0
      AND s.MonthlyCONV_ALM_TransfertRate IS NOT NULL
      AND s.DT_CLOSE <= '2025-06-24'                      -- важное новое условие
),
/*====================================================================
   2. Формируем список уникальных (CON_ID, Target_DT) — чтобы
      к балансовой витрине обращаться ровно по тем ключам, которые нужны
====================================================================*/
keys AS (
    SELECT DISTINCT
           d.CON_ID,
           d.Target_DT
    FROM   deals d
),
/*====================================================================
   3. Забираем rate_trf из VW_Balance_Rest_All
      — только для пар из keys, только rate_trf NOT NULL
====================================================================*/
rates AS (
    SELECT
        br.CON_ID,
        br.DT_REP,
        br.rate_trf
    FROM   ALM.ALM.VW_Balance_Rest_All br  WITH (NOLOCK /* +INDEX(IX_CONID_DTREP) */)
    JOIN   keys k
           ON  k.CON_ID   = br.CON_ID
           AND k.Target_DT = br.DT_REP
    WHERE  br.rate_trf IS NOT NULL
)
/*====================================================================
   4. Итог: соединяем сделки с найденными ставками (LEFT JOIN —
      чтобы депозит не «потерялся», если ставки всё-таки нет)
====================================================================*/
SELECT
    d.CON_ID,
    d.MATUR,
    d.DT_OPEN,
    d.CONVENTION,
    d.Nadbawka,
    r.rate_trf       AS [rate_trf]          -- может быть NULL, если нет снимка
FROM   deals d
LEFT JOIN rates r
       ON r.CON_ID = d.CON_ID
      AND r.DT_REP = d.Target_DT
ORDER BY d.DT_OPEN, d.CON_ID;
```

### Почему этот вариант быстрее

| Шаг       | Что читаем                                                                                                                              | Объём               |
| --------- | --------------------------------------------------------------------------------------------------------------------------------------- | ------------------- |
| **keys**  | только уникальные `(CON_ID, DT_CLOSE-5)`                                                                                                | ≤ кол-ва сделок     |
| **rates** | из огромной балансовой витрины — **только** строки, попавшие в `keys`, и сразу по точному ключу на составном индексе `(CON_ID, DT_REP)` | минимально возможно |
| **JOIN**  | обычный `LEFT JOIN` по первичному ключу, без оконных функций                                                                            | лёгкий              |

> **Индекс, который даст максимальный эффект**
>
> ```sql
> CREATE INDEX IX_VW_Balance_CONID_DTREP
>     ON ALM.ALM.VW_Balance_Rest_All ( CON_ID, DT_REP );
> ```
>
> (если он уже есть — отлично; если нет — создание займёт минуты, а
> ускорит все подобные запросы).

### Что будет, если для (CON\_ID, DT\_CLOSE-5) нет записи

* В колонке **`rate_trf`** вернётся `NULL` (из-за `LEFT JOIN`);
* депозит всё равно останется в выборке — вы сами решите, что с ним делать
  (отфильтровать, показать как «нет ставки» и т.д.).

Если нужна жёсткая фильтрация «оставить только те, где ставка нашлась» —
замените `LEFT JOIN` на `INNER JOIN`.
