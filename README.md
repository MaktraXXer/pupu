— то для корректного импорта в Python я бы назвал колонки так:

text
Копировать
Редактировать
Date
saldo
prm_90
prm_180
prm_365
prm_max1Y
prm_mean1Y
Тогда в коде достаточно:

python
Копировать
Редактировать
import pandas as pd

df_xl = pd.read_excel('твоя_таблица.xlsx', 
                      parse_dates=['Date'], 
                      dayfirst=True,
                      dtype={'saldo': float,
                             'prm_90': float, 'prm_180': float,
                             'prm_365': float, 'prm_max1Y': float,
                             'prm_mean1Y': float})
df_xl.set_index('Date', inplace=True)

# если в Excel у тебя были пропуски, и ты хочешь их заполнить
df_xl = df_xl.ffill()

# теперь можно сразу запустить
print(both_corrs(df_xl))
— и сравнить получившийся вывод с тем, что Excel выдаёт формулой =КОРРЕЛ(…).

Есть несколько «мест», где два инструмента могут не «стыковаться» и дать совсем разные \(r\)-ы, хотя, на первый взгляд, вы берёте одни и те же числа:

---

### 1. Разные подпоследовательности дат  
- **Python‑сегмент** вы делаете строго по границам (`daily.loc['2024-05-01':'2024-06-03']`), а в Excel вы, кажется, взяли «до 4 июня включительно». Один лишний день (или пропущенный) — и коэффициент может плясать совсем по‑другому, особенно на коротких отрезках.  
- Проверьте, чтобы в обоих случаях было ровно одни и те же даты: одинаковый «начало» и одинаковый «конец», и ни дня не лишнего.

### 2. Пропуски и нестягивание диапазонов  
- В Python вы делаете `prem = prem.reindex(df.index).ffill()`, т.е. вы гарантированно получили 472 числа без пропусков.  
- В Excel при VLOOKUP’е могли появиться `#N/A` или пустые ячейки там, где нет точного попадания по дате.  
- Функция `=КОРРЕЛ(…)` в Excel автоматически игнорирует пары, где хотя бы один элемент не число. В итоге вы считаете корреляцию по «своему» подмножеству дней, а не по тем же 472 точкам.

### 3. Точность и округления  
- Если вы копировали из Python в Excel уже отформатированные ячейки (с «1,34 %»), это могло обрезать цифры: 0.013465 → 0.0134 и так далее.  
- Excel считает по **подставленным** значениям (0.0134), Python — по тем, что в памяти (0.013465238…). Даже небольшие отличия на сотые‑тысячные в каждом из 472 наблюдений накапливаются и смещают \(r\).

### 4. Неправильный диапазон в формуле  
- Убедитесь, что вы действительно протянули `=КОРРЕЛ($B$2:$B$473;\;C$2:$C$473)` (или сколько у вас строк), а не протянули корелляцию только по первым 100–200 дням.  
- Иногда мышкой тянут чуть не там или оставляют заголовок в диапазоне — и Excel сам «отрезает» массив.

---

## Как убедиться «лицом к лицу»

1. **Выгрузите ту самую таблицу из Excel** (с вашими `VLOOKUP`‑ами) в файл, например `joined.xlsx`.  
2. Дайте столбцам **точно такие имена**, чтобы в Python они автоматически встали на свои места:
   ```text
   Date                   ← в этой колонке ваши даты, формат ДД.MM.ГГГГ
   saldo                  ← сумма по полю «Сальдо»
   prm_90                 ← разница ставок ДОМА – средняя по рынку (90‑дн.)
   prm_180                ← то же для 180‑дн.
   prm_365  
   prm_max1Y              ← максимальная ставка до 1 г.
   prm_mean1Y             ← среднее арифм. ставок до 1 г.
   ```
3. В Python:
   ```python
   import pandas as pd

   # читаем ваш экспорт из Excel
   df_xl = pd.read_excel('joined.xlsx',
                        parse_dates=['Date'],
                        dayfirst=True)

   df_xl.set_index('Date', inplace=True)

   # если в Excel были пробелы/#N/A, заполняем их
   df_xl = df_xl.ffill()

   # убеждаемся, что всё числовое
   df_xl = df_xl.astype(float)

   # и считаем точно теми же функциями
   print('Полная корреляция:')
   display(both_corrs(df_xl))

   print('С 01-05-2024:')
   display(both_corrs(df_xl.loc['2024-05-01':]))

   # для сегментов, если нужно — точно так же
   ```
4. Сравните результат `both_corrs(df_xl)` с тем, что выдаёт Excel.  
   Если после этого они **совпадут**, значит дело было в наборе дат/пустых ячейках/округлениях.  
   Если **всё ещё будут расхождения**, глянем глубже — но сначала давайте убедимся, что действительно «даём в оба калькулятора» ровно один и тот же массив чисел по одним и тем же индексам. 
   
---

Предлагаю начать с такого импорта и первых выводов. Как назовёте колонки — скопируйте их в точности, покажите, и мы сразу сможем на чистом примере «лицом к лицу» увидеть, где уходит расхождение.
